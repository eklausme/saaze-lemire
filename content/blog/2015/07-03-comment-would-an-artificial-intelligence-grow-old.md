---
date: "2015-07-03 12:00:00"
title: "Would an artificial intelligence &#8220;grow old&#8221;?"
index: false
---

[6 thoughts on &ldquo;Would an artificial intelligence &#8220;grow old&#8221;?&rdquo;](/lemire/blog/2015/07-03-would-an-artificial-intelligence-grow-old)

<ol class="comment-list">
<li id="comment-171887" class="comment even thread-even depth-1">
<div class="comment-author vcard">
<img alt src="https://secure.gravatar.com/avatar/c71711062c1eea90e0f64c678ba1519b?s=56&#038;d=mm&#038;r=g" srcset="https://secure.gravatar.com/avatar/c71711062c1eea90e0f64c678ba1519b?s=112&#038;d=mm&#038;r=g 2x" class="avatar avatar-56 photo" height="56" width="56" decoding="async" /> <b class="fn"><a href="http://tachyondecay.net" class="url" rel="ugc external nofollow">Ben Babcock</a></b> <span class="says">says:</span> </div>
<div class="comment-metadata"><time datetime="2015-07-03T15:15:51+00:00">July 3, 2015 at 3:15 pm</time></a> </div>
<div class="comment-content">
<p>I wonder how much of the original Linux or Apache codebase has survived to the present day. Perhaps these projects are the exception because of the amount of changes. So we don&rsquo;t have a linear relationship but a quadratic one: software that receives few modifications or a great many is resilient, while software that only receives a few, infrequent updates is susceptible.</p>
<p>So an AI would keep growing, keep learning, but it would become a Ship of Theseus, where eventually all of its original code has been replaced.</p>
</div>
</li>
<li id="comment-171889" class="comment byuser comment-author-lemire bypostauthor odd alt thread-odd thread-alt depth-1">
<div class="comment-author vcard">
<img alt src="https://secure.gravatar.com/avatar/2ca999bef9535950f5b84281a4dab006?s=56&#038;d=mm&#038;r=g" srcset="https://secure.gravatar.com/avatar/2ca999bef9535950f5b84281a4dab006?s=112&#038;d=mm&#038;r=g 2x" class="avatar avatar-56 photo" height="56" width="56" decoding="async" /> <b class="fn"><a href="https://lemire.me/en/" class="url" rel="ugc">Daniel Lemire</a></b> <span class="says">says:</span> </div>
<div class="comment-metadata"><time datetime="2015-07-03T15:30:11+00:00">July 3, 2015 at 3:30 pm</time></a> </div>
<div class="comment-content">
<p>@Ben</p>
<p><em>I wonder how much of the original Linux or Apache codebase has survived to the present day. Perhaps these projects are the exception because of the amount of changes. </em></p>
<p>I do not know how much of the original Linux kernel source code remains today. Probably very little. (We could easily quantify this problem since we do have the source code.) </p>
<p>Is it an exception? I think not. Most code that I have constantly updated for many years has been rewritten iteratively many times.</p>
<p><em>So an AI would keep growing, keep learning, but it would become a Ship of Theseus, where eventually all of its original code has been replaced.</em></p>
<p>Most cells in your body will die and be replaced in the next few months. Your connectome is constantly changing. You are probably very different, as far as your brain is concerned, from when you were 1 year old.</p>
<p>But change itself is not aging. There are organisms that are effectively immortal, yet their cells are being replaced all the time.</p>
<p> We would definitively expect an AI to be evolving deeply. In fact, we should expect an AI to be able to evolve at an accelerated rate.</p>
</div>
</li>
<li id="comment-171952" class="comment even thread-even depth-1">
<div class="comment-author vcard">
<img alt src="https://secure.gravatar.com/avatar/8e2e3a01bf33747391457d97e0df832b?s=56&#038;d=mm&#038;r=g" srcset="https://secure.gravatar.com/avatar/8e2e3a01bf33747391457d97e0df832b?s=112&#038;d=mm&#038;r=g 2x" class="avatar avatar-56 photo" height="56" width="56" loading="lazy" decoding="async" /> <b class="fn">Andre Vellino</b> <span class="says">says:</span> </div>
<div class="comment-metadata"><time datetime="2015-07-03T21:29:21+00:00">July 3, 2015 at 9:29 pm</time></a> </div>
<div class="comment-content">
<p>I know for a fact that Hanson&rsquo;s law of computing is true in at least one software intensive environment: good old fashioned centralized telephone switches. The bigger Nortel switching software grew, the more brittle it became. </p>
<p>I think the Hanson&rsquo;s law is true for *some* kinds of software systems &#8211; those that are, as you say Daniel, not modular or flexible &#8211; and that is encouraged by some kinds of software development methodologies (e.g. &ldquo;cathedrals&rdquo;).</p>
<p>In Nortel switching software, everything depended on everything else (not quite an accurate characterization, but close). They saw this happening and did a lot of refactoring but (I&rsquo;m quoting a director) &ldquo;it was like changing the wheels on a tractor-trailer while it was in motion&rdquo;. </p>
<p>In addition there was as culture of code at Nortel that encouraged a lot of cloning. &ldquo;I&rsquo;m being told to write &lsquo;feature X&rsquo; so I&rsquo;ll just copy &lsquo;feature Y&rsquo; written by my buddy in the next cubicle and modify the bits I understand to do what I need. </p>
<p>Hence the volume of code would grow very fast, compile very slowly, propagate hidden bugs and so on. Quite a bit of effort was spent at Nortel writing meta-code that would analyse how the cloning was happening.</p>
<p>Really smart software systems that are able to build new ones are not going to encounter that problem &#8211; or at least, they will solve it.</p>
</div>
</li>
<li id="comment-172293" class="comment odd alt thread-odd thread-alt depth-1">
<div class="comment-author vcard">
<img alt src="https://secure.gravatar.com/avatar/eddf956306e6fb299f7291b4a2ccea11?s=56&#038;d=mm&#038;r=g" srcset="https://secure.gravatar.com/avatar/eddf956306e6fb299f7291b4a2ccea11?s=112&#038;d=mm&#038;r=g 2x" class="avatar avatar-56 photo" height="56" width="56" loading="lazy" decoding="async" /> <b class="fn"><a href="https://c0de517e.blogspot.com" class="url" rel="ugc external nofollow">Angelo</a></b> <span class="says">says:</span> </div>
<div class="comment-metadata"><time datetime="2015-07-04T21:42:20+00:00">July 4, 2015 at 9:42 pm</time></a> </div>
<div class="comment-content">
<p>Your interesting post made me write this one, sort-of related.</p>
<p><a href="http://c0de517e.blogspot.ca/2015/07/the-following-provides-no-answers-just.html" rel="nofollow ugc">http://c0de517e.blogspot.ca/2015/07/the-following-provides-no-answers-just.html</a></p>
</div>
</li>
<li id="comment-245285" class="comment even thread-even depth-1 parent">
<div class="comment-author vcard">
<img alt src="https://secure.gravatar.com/avatar/07f2a57fc1bf6585bc68ec07d954e1d5?s=56&#038;d=mm&#038;r=g" srcset="https://secure.gravatar.com/avatar/07f2a57fc1bf6585bc68ec07d954e1d5?s=112&#038;d=mm&#038;r=g 2x" class="avatar avatar-56 photo" height="56" width="56" loading="lazy" decoding="async" /> <b class="fn">Alex</b> <span class="says">says:</span> </div>
<div class="comment-metadata"><time datetime="2016-06-24T21:34:15+00:00">June 24, 2016 at 9:34 pm</time></a> </div>
<div class="comment-content">
<p>&ldquo;Torvalds wrote the original Linux kernel as a tool to run Unix on 386 PCsâ€¦ Modern-day Linux is thousands of times more flexible.&rdquo;</p>
<p>It&rsquo;s more flexible in some ways, but less in others.</p>
<p>For example, clearly Linux runs on thousands of off-the-shelf computers today, which it did not originally. Then again, have you ever tried to write a new module for Linux? In the 0.0.x days, it was super easy to extend Linux. Today, it&rsquo;s huge and complex and extremely daunting to get started. A modern Linux module needs dozens of things to be perfect before it will even load.</p>
<p>Or let&rsquo;s say you want to change some interface. In the 0.0.x days, this was easy: you just change it. Today you&rsquo;ve got to deal with hundreds of device drivers, millions (billions? probably) of installed copies of the kernel that can&rsquo;t or won&rsquo;t be upgraded, thousands of programmers who know and expect the old way.</p>
<p>Linux today has a lot more mass than in the 386 days. That mass can support an incredible array of devices, and work around real-world problems with those devices, and even make it run faster than before. But it&rsquo;s still mass. That makes it more complex, and slower to change course. The market has declared that &ldquo;runs on every PC&rdquo; is more valuable than &ldquo;is easy to understand and hack on&rdquo;, and that&rsquo;s fine, but I wouldn&rsquo;t go so far as to say it&rsquo;s &ldquo;thousands of times more flexible&rdquo;. To me, it&rsquo;s less flexible.</p>
</div>
<ol class="children">
<li id="comment-245289" class="comment byuser comment-author-lemire bypostauthor odd alt depth-2">
<div class="comment-author vcard">
<img alt src="https://secure.gravatar.com/avatar/2ca999bef9535950f5b84281a4dab006?s=56&#038;d=mm&#038;r=g" srcset="https://secure.gravatar.com/avatar/2ca999bef9535950f5b84281a4dab006?s=112&#038;d=mm&#038;r=g 2x" class="avatar avatar-56 photo" height="56" width="56" loading="lazy" decoding="async" /> <b class="fn"><a href="https://lemire.me/en/" class="url" rel="ugc">Daniel Lemire</a></b> <span class="says">says:</span> </div>
<div class="comment-metadata"><time datetime="2016-06-24T22:37:41+00:00">June 24, 2016 at 10:37 pm</time></a> </div>
<div class="comment-content">
<p><em>For example, clearly Linux runs on thousands of off-the-shelf computers today, which it did not originally.</em></p>
<p>Linux today runs on everything from routers, televisions to mobile phones (Android), game consoles (Steam) and all the way supercomputers. When Linus started out, Linux was good for one thing: a fun week-end project. Today it is a massively powerful tool used for purposes Linus could not even imagine. I stand by my statement, Linux is orders of magnitude more flexible.</p>
<p><em>Then again, have you ever tried to write a new module for Linux?</em></p>
<p>Yes. And I have had students with relatively little experience do it. If you know C, it is a simple matter. Moreover, you can do it today on platforms where Linux could not run years ago. And, come on, a kid can compile a custom Linux kernel with ease today. It is also better documented than it never was. But let us concede the point that, in general, programming today is more daunting than it was 20 years ago. Compilers have more options. We have more libraries. Libraries have gotten larger. Kernels have gotten much larger. Hardware is far more sophisticated. We have more tools. But programmers today can achieve so much more&#8230; You simply could not do a lot with a computer 20 years ago. They were simpler&#8230; but also far more limited.</p>
<p>Let me work by analogy. Is a man living in a hut in 1000BC more flexible than a man living in Los Angeles today? No. The man from 1000BC had a simple life, but his options were drastically limited. Today, a men in Los Angeles can do so many things&#8230;</p>
<p><em>Or let&rsquo;s say you want to change some interface.</em></p>
<p>It is a choice, right? You can be like Apple and just do it. Or you can be cautious and preserve backward compatibility all the way to the beginning of the universe.</p>
<p>You can choose to age your software by restricting it so that it can only do whatever it did in the past. Or you can expand it as needed. The software industry tends to favor the latter. </p>
<p><em>That makes it more complex, and slower to change course.</em></p>
<p>Intuitively, one might think so, but does it? One might think that operating systems today are stuck and can&rsquo;t evolve. But we have lots of contrary evidence. They are changing fast.</p>
<p><em>â€œis easy to understand and hack onâ€</em></p>
<p>You can hack Linux to do things that were improbable 20 years ago&#8230; I do lots of hacking for fun&#8230; See <a href="https://lemire.me/blog/2016/04/02/setting-up-a-robust-minecraft-server-on-a-raspberry-pi/" rel="ugc">http://lemire.me/blog/2016/04/02/setting-up-a-robust-minecraft-server-on-a-raspberry-pi/</a></p>
</div>
</li>
</ol>
</li>
</ol>
